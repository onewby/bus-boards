# Populate location database tables - run stance_grouping.py first to generate localities.json

import json
import typing
from xml.etree.ElementTree import *

from defusedxml.ElementTree import parse
import sqlite3


class StopData(typing.TypedDict):
    ATCOCode: str
    Lat: float
    Long: float
    Street: str
    Indicator: str


# Parse locality XML into tuples
def convert_locality(locality):
    code = locality.findtext(".//{http://www.naptan.org.uk/}NptgLocalityCode")
    name = locality.findtext(".//{http://www.naptan.org.uk/}LocalityName")
    qualifier = locality.findtext(".//{http://www.naptan.org.uk/}QualifierName")
    parent = locality.findtext(".//{http://www.naptan.org.uk/}ParentNptgLocalityRef")
    long = locality.findtext(".//{http://www.naptan.org.uk/}Longitude")
    lat = locality.findtext(".//{http://www.naptan.org.uk/}Latitude")
    if long is not None:
        long = float(long)
    if lat is not None:
        lat = float(lat)
    return code, name, qualifier, parent, long, lat


def main():
    # Connect to stops database
    db = sqlite3.connect("bus-site/stops.sqlite")

    # Import NPTG locality data and parse XML
    tree: ElementTree = parse("NPTG.xml")
    root = tree.getroot()
    localities = root.findall(".//{http://www.naptan.org.uk/}NptgLocality")

    # Parse localities into objects
    data = [convert_locality(locality) for locality in localities]

    # Add localities to the database
    db.executemany("REPLACE INTO localities (code, name, qualifier, parent, lat, long) VALUES (?, ?, ?, ?, ?, ?)", data)
    db.execute("DROP TABLE localities_search")
    db.execute("CREATE VIRTUAL TABLE localities_search USING fts5(name, qualifier, code UNINDEXED)")
    db.execute("INSERT INTO localities_search(name, qualifier, code) SELECT name, qualifier, code FROM localities")

    # Open the stop data generated by stance_grouping.py
    with open("localities.json", "r") as stops_file:
        stops_data: dict[str, dict[str, list[StopData]]] = json.load(stops_file)

    # Clear existing data
    db.execute("DELETE FROM stops")
    db.execute("DELETE FROM stances")

    # Import stops
    for locality, stops in stops_data.items():
        for stop, stances in stops.items():
            stop_id = db.execute("INSERT INTO stops (name, locality) VALUES (?, ?) RETURNING id", (stop, locality)).fetchone()[0]
            for stance in stances:
                code = stance["ATCOCode"]
                lat = stance["Lat"]
                long = stance["Long"]
                street = stance["Street"]
                indicator = stance["Indicator"]
                db.execute("INSERT INTO stances (code, street, indicator, lat, long, stop) VALUES (?, ?, ?, ?, ?, ?)", (code, street, indicator, lat, long, stop_id))

    # Generate locality names based on locality hierarchy
    db.execute("""UPDATE stops SET locality_name =
                     (SELECT GROUP_CONCAT(name, ' â€º ') FROM (
                        WITH RECURSIVE
                            find_parent_names(level, code) AS (
                                VALUES(0, stops.locality)
                                UNION
                                SELECT level+1, parent FROM localities, find_parent_names
                                WHERE localities.code=find_parent_names.code
                            )
                        SELECT name FROM localities, find_parent_names
                        WHERE localities.code = find_parent_names.code
                        ORDER BY level desc
                    ));
    """)

    # Reset and populate the stop search database
    db.execute("DROP TABLE stops_search")
    db.execute("CREATE VIRTUAL TABLE stops_search USING fts5(name, parent, qualifier, id UNINDEXED)")
    db.execute("INSERT INTO stops_search(name, parent, qualifier, id) SELECT stops.name, stops.locality_name, qualifier, stops.id FROM stops INNER JOIN localities l on l.code = stops.locality")

    # Commit to the database
    db.commit()
    db.close()


if __name__ == "__main__":
    main()
