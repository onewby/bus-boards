/*
 * Transport for London Unified API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::tflapi::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`journey_journey_results`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JourneyJourneyResultsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`journey_meta`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JourneyMetaError {
    UnknownValue(serde_json::Value),
}


pub async fn journey_journey_results(configuration: &configuration::Configuration, from: &str, to: &str, via: Option<&str>, national_search: Option<bool>, date: Option<&str>, time: Option<&str>, time_is: Option<&str>, journey_preference: Option<&str>, mode: Option<Vec<String>>, accessibility_preference: Option<Vec<String>>, from_name: Option<&str>, to_name: Option<&str>, via_name: Option<&str>, max_transfer_minutes: Option<&str>, max_walking_minutes: Option<&str>, walking_speed: Option<&str>, cycle_preference: Option<&str>, adjustment: Option<&str>, bike_proficiency: Option<Vec<String>>, alternative_cycle: Option<bool>, alternative_walking: Option<bool>, apply_html_markup: Option<bool>, use_multi_modal_call: Option<bool>, walking_optimization: Option<bool>, taxi_only_trip: Option<bool>, route_between_entrances: Option<bool>, use_real_time_live_arrivals: Option<bool>, calc_one_direction: Option<bool>, include_alternative_routes: Option<bool>, override_multi_modal_scenario: Option<i32>, combine_transfer_legs: Option<bool>) -> Result<models::TflPeriodApiPeriodPresentationPeriodEntitiesPeriodJourneyPlannerPeriodItineraryResult, Error<JourneyJourneyResultsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/Journey/JourneyResults/{from}/to/{to}", local_var_configuration.base_path, from=crate::tflapi::apis::urlencode(from), to=crate::tflapi::apis::urlencode(to));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = via {
        local_var_req_builder = local_var_req_builder.query(&[("via", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = national_search {
        local_var_req_builder = local_var_req_builder.query(&[("nationalSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date {
        local_var_req_builder = local_var_req_builder.query(&[("date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time {
        local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_is {
        local_var_req_builder = local_var_req_builder.query(&[("timeIs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = journey_preference {
        local_var_req_builder = local_var_req_builder.query(&[("journeyPreference", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mode {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("mode".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("mode", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = accessibility_preference {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("accessibilityPreference".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("accessibilityPreference", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = from_name {
        local_var_req_builder = local_var_req_builder.query(&[("fromName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_name {
        local_var_req_builder = local_var_req_builder.query(&[("toName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = via_name {
        local_var_req_builder = local_var_req_builder.query(&[("viaName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_transfer_minutes {
        local_var_req_builder = local_var_req_builder.query(&[("maxTransferMinutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_walking_minutes {
        local_var_req_builder = local_var_req_builder.query(&[("maxWalkingMinutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = walking_speed {
        local_var_req_builder = local_var_req_builder.query(&[("walkingSpeed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle_preference {
        local_var_req_builder = local_var_req_builder.query(&[("cyclePreference", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = adjustment {
        local_var_req_builder = local_var_req_builder.query(&[("adjustment", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = bike_proficiency {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("bikeProficiency".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("bikeProficiency", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = alternative_cycle {
        local_var_req_builder = local_var_req_builder.query(&[("alternativeCycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = alternative_walking {
        local_var_req_builder = local_var_req_builder.query(&[("alternativeWalking", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = apply_html_markup {
        local_var_req_builder = local_var_req_builder.query(&[("applyHtmlMarkup", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = use_multi_modal_call {
        local_var_req_builder = local_var_req_builder.query(&[("useMultiModalCall", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = walking_optimization {
        local_var_req_builder = local_var_req_builder.query(&[("walkingOptimization", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = taxi_only_trip {
        local_var_req_builder = local_var_req_builder.query(&[("taxiOnlyTrip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = route_between_entrances {
        local_var_req_builder = local_var_req_builder.query(&[("routeBetweenEntrances", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = use_real_time_live_arrivals {
        local_var_req_builder = local_var_req_builder.query(&[("useRealTimeLiveArrivals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = calc_one_direction {
        local_var_req_builder = local_var_req_builder.query(&[("calcOneDirection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_alternative_routes {
        local_var_req_builder = local_var_req_builder.query(&[("includeAlternativeRoutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = override_multi_modal_scenario {
        local_var_req_builder = local_var_req_builder.query(&[("overrideMultiModalScenario", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = combine_transfer_legs {
        local_var_req_builder = local_var_req_builder.query(&[("combineTransferLegs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<JourneyJourneyResultsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn journey_meta(configuration: &configuration::Configuration, ) -> Result<Vec<models::TflPeriodApiPeriodPresentationPeriodEntitiesPeriodMode>, Error<JourneyMetaError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/Journey/Meta/Modes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<JourneyMetaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

